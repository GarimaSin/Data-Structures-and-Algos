1) For input given in the form of Integers, ask - 
	if -ve integers is present 
	if 0 is present
	if nos. are repeated
	if nos. are sorted
	if always given to find a VALID case	
	
	
	
THEORY:
1)  CombWRep Inclusion/Excl - code is same as for loop code. In For loop code, we simulate inclusion by adding the cu. val in the string and 
	simulate exclusion by replacing the new string with the old one
	

2)  Perm/Comb output order in special sequence - 
	If we want specific pattern like in paranthesis comb. {open "(" shud always come b4 close ")"}, 
		USE INCLUDE/EXCLUDE and
		Put a check as per the requirement eg. If(close > open) return; 
		put that part of recursive call (that has to come first in answer) before , b4 the part that is expected later.
		
3)  To get UNIQUE COMB/PERM in case of repeated i/ps 
		Sort the array
		check if i and i-1 are equal then continue; if(i>0 && !vis[i-1] && nums[i] == nums[i-1])  continue;
		MIND THE 2nd CONDITION = VIS[ I - 1 ]  AND NOT I
		Eg. CombinationSum2 		
		
		
4)  In recursion - To return the answer in List<list<>> - create a new list with the old list's value and assign it to outer list.
		Eg. CombinationSum_Mine -  line 30
		
5)  Power Set -
		Same code is Comb W Rep (not incl/excl)
		Only change - when calling recursively, replace i with i+1 (for the input 'start')
		Add the list in answer list at the beginning only (no condition)
		
		
6)  Decomposition -
		Same code as Power Set Except
			For the list at the beginning, add a condition if 'start' = input.length.
			Take a substring from 'start' to i+1 in for loop
			Eg. Decomposition code, Palindrome Partitioning
		
		

6)  To find Largest or smallest - 
		Use HEAPS Eg. KthLargestElementInAnArray
		
7)  SORTING USING HEAP IS O(n)  